//
// Created by alpharius on 04.02.2020.
//

#ifndef ARBITRARY_PRECISION_NUMBER_NUMBER_H
#define ARBITRARY_PRECISION_NUMBER_NUMBER_H

#include <stdbool.h>

/*
 * реализую тип числа с наперед заданной точностью (передавая параметр числа значащих цифр в указатель)
 * после значащих цифр следует 5-10 цифр машинного нуля - отстойник для ошибок, который нужен, чтобы
 * реализовывать операции деления - когда "схождение" к реальному ответу находится на 5м из 10 знаков
 * которые отведены под ошибки
 *
 * amount_of_signs - дает нам границы рассмотрения памяти (без отстойника ошибок)
 * *data - указатель на область памяти в которой хранятся байты числа
 * приведена неоптимальная (пробная реализация) в виде массива интов
 * a[0] - знак
 * a[1] - показатель степени
 * a[2..n-1] - значащие цифры по разрядам
 *
 */

typedef struct _number {
    int amount_of_signs;
    int* data;
} Number;

/*                          ТАБЛИЦА МЕТОДОВ                             */
// один + выполнил, два плюса - протестировал

Number new_Number(int);                     // конструктор....................................................+
void del_Number(Number*);                   // освобождает место в памяти.....................................+


// арифметические операции
Number ADD(Number*, Number*);               // сложение.......................................................++
Number SUBSTRACT(Number*, Number*);         // вычитание......................................................+
Number MULTIPLY(Number*, Number*);          // умножение......................................................++
Number DEVIDE(Number*, Number*);            // деление........................................................-
Number POW(Number*, Number*);               // возведение в степень...........................................-
Number SQR(Number*, Number*);               // извлечение произвольного корня.................................-
void ABS(Number*);                          // превращает переданное число в положительное....................+
void EQUATE(Number*, Number*);              // приравнивание значений аналог знака = для встроенных типов.....+

// операции конвертации
double Number_to_double(Number*);           // конвертация в число с двойной точностью........................-
Number double_to_Number(double);            // конвертация числа с двойной точностью в Number.................-
char* Number_to_string(Number*);            // конвертация в строковое представление..........................+
Number string_to_Number(const char*, int);  // конвертация строки в Number....................................+

// служебные функции :::DEBUG:::
void Number_simple_print(Number*);          // простецкий вывод записанного...................................+
void Number_move_right(Number*);            // сдвинуть на одну позицию вправо и поменять степень.............+
void Number_move_right_pos(Number*, int);   // сдвинуть на сколько то позиций вправо..........................+
void Number_move_left(Number*);             // единичный сдвик в лево при условии что старший разряд 0........+         012 -> 120
void Number_move_left_pos(Number*, int);    // сдвинуть на сколько то позиций влево...........................+
Number Number_copy(Number*);                // производим копирование памяти одного числа в другое............+

// операторы порядка
bool EQUAL(Number*, Number*);               // проверка на равенство двух чисел...............................+
bool LE(Number*, Number*);                  // проверка на <=.................................................+
bool GE(Number*, Number*);                  // проверка на >=.................................................+



#endif //ARBITRARY_PRECISION_NUMBER_NUMBER_H
